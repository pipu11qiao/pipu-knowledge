# react

## react 哲学

### react 哲学的问题

问题： react开发包含了哪些步骤

问题： 如何将UI拆解为组件层级的结构

问题： 单一职责在react中的运用

问题： 如何构建静态版本

问题： 什么是react单向数据流

问题： 如何找出UI精简且完整的state表示

问题： 哪些不是state

问题： 什么是dry

问题： 为啥要找出绝对精简的state

问题： 如何 验证state应该被放置在哪里

问题: 交互函数放到哪里


### oreact 哲学的问题详情

##### 问题：react开发包含了哪些步骤

将UI拆解为组件层级的结构

构建静态版本

找出UI精简且完整的state表示

验证state应该被放置在哪里

添加反向数据路

重点是找出UI精简并且表示完整的state，单一功能原则，dry原则，单向数据流，数据不可变性。

##### 问题： 如何将UI拆解为组件层级的结构 

根据原型来拆分，ui设计是会考虑ui设计和交互方式

程序设计。根据单一功能原则决定是否要创建一个对象或函数，理想情况下一个react组件只完成一件事情，随着功能的增加和扩大， 拆分成更多的组件

CSS 思考你将把类选择器用于何处。（然而，组件并没有那么细的粒度。）

设计 思考你将如何组织布局的层级

##### 问题： 单一职责在react中的运用

Single Responsibility Principle,SRP是面向对象设计中的一个重要职责。核心思想是： 一个类应该只有一个职责，且这个职责应该被完全封装在这个类中。

在react中单一功能职责原则在组件中很好的运用。

对于一个组件，对外完成一个功能。这里面包含了很多的概念，对于功能拆分常见的有ui部分，数据获取部分，交互逻辑部分，这些都可以单独作为一个组件被开发。是否要做到这个粒度，需要根据当前的业务来看，如果已经开发的被复用，可以在重构过程进行拆分。

举例来说，对于一个通过用户接口获取用户信息并展示的组件，可以分成

用户组件

调用用户接口获取用户信息逻辑部分

用户信息展示的ui部分

交互部分

##### 问题： 如何构建静态版本

对着ui分层构建静态版本的代码，自上而下还是自下而上都可以。在简单的例子中，自上而下构建通常更简单；而在大型项目中，自下而上构建更简单。

##### 问题： 什么是react单向数据流

指的是组件间的数据传递方向，只能由父组件向子组件传递。反过来不能传递。如果子组件需要修改父组件中的数据，必须通过调用父组件传递下来的回调函数来实现，这个回调函数会在父组件中更新状态，然后再将新的状态或数据传递给子组件。

##### 问题： 如何找出UI精简且完整的state表示

为了使UI可交互，你需要用户更改潜在的数据结构。你将可以使用state进行实现。

考虑将state作为应用程序需要记住改变数据的最小集合。组织state最重要的一条原则是保持它DRY（不要自我重复）。计算出你应用程序需要的绝对精简的state表示，按需计算其它一切。举个例子，如果你正在构建一个购物列表，你可将他们在state中存储为数组。如果你同时想展示列表中物品数量，不需要将其另存为一个新的state。而是通过读取你数组的长度来实现。

通过列出改变数据的地方，来找出所有的可能的state

##### 问题： 哪些不是state

随着时间推移保持不变？如此，便不是state。

通过props从父组件传递？如此，便不是state

是否可以基于以存在于组件中的state或者props进行计算？如此，它肯定不是state!

##### 问题： 什么是dry

don't repeat yourself,避免重复
系统中的任何一块知识（逻辑或信息）都应该在一个系统内有且只有一个、唯一可信的“来源”或“表现形式“

##### 问题：为啥要找出绝对精简的state

开销

不必要的render

状态越少，追踪问题越简单

逻辑更聚合，更符合直觉

##### 问题： 如何 验证state应该被放置在哪里

验证哪个组件是通过改变state实现可响应的，或者拥有这个state。记住：React使用单向数据流，通过组件层级结构从父组件传递数据至子组件。

验证每一个基于特定state渲染的组件

寻找 它们最近并且共同的父组件-在层级结构中，一个凌驾于他们所有组件之上的组件。

决定state应该被放置于哪里：

通常情况下，你直接放置state与他们的共同的父组件。

你也可以将state放置于它们父组件的上层组件

如果你找不到一个合适来放这个state的地方，单独创建一个新的组件去管理这个state，并将它添加到它们父组件上层的某个地方。

##### 问题： 交互函数放到哪里

交互函数放到哪里和state相关，确定了state的位置，如果一个函数影响这个这个state，那么这个交互函数就应该被定义在这个函数的部分


## react 官网教程基本

### react 官网教程基本的问题

问题： 创建react应用的方式

问题： react中常用的ts类型

问题： 常见方法的ts知识

问题： 常见事件ts

问题： React 开发者工具

问题： React Compiler 介绍

问题： immer 进行state更新

问题： Object.freeze 介绍

问题： immer freeze和produce的原理，简单说说

问题：自己开发的produce的思路

问题：自己开发的produce的问题

symbo作为属性和普通的字符串有什么不同

问题：实际produce方法的原理

### react 官网教程基本的详情

##### 问题： 创建react应用的方式

- [Next.js 的 App Router](https://nextjs.org/docs)   是一个 React 框架，充分利用了 React 的架构，支持全栈 React 应用。 主要部署到node.js或serverless的托管平台，或者部署到你自己的服务器。

- [React Router](https://reactrouter.com/start/framework/installation)   可以与 Vite 结合创建一个全栈 React 框架，标准的web api 

- [Expo](https://expo.dev/)  让你可以创建支持真正原生 UI 的通用 Android、iOS 和 Web 应用  react native

- [从零开始构建 React 应用](https://zh-hans.react.dev/learn/build-a-react-app-from-scratch)

##### 问题： react中常用的ts类型

- 尝试阅读 @types/react   [DefinitelyTyped 的 React 目录中](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts)

- Dom 事件 写独立的事件处理函数，需要明确定义函数参数的类型，React.ChangeEvent<HTMLInputElement>,完整列表可以在 [这里](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/b580df54c0819ec9df62b0835a315dd48b8594a9/types/react/index.d.ts#L1247C1-L1373) 查看

- 子元素。 React.ReactNode 在JSX中作为子元素传递的所有可能类型的并集,React.ReactElement 它只包括JSX元素，而不包括js原始类型，如string或number

- 样式属性 React.CSSProperties

##### 问题： 常见方法的ts知识

useState,useContext在初始化不是唯一的泛型，需要使用时加问号，可以通过一个hook来排除控制。判断为空抛出错误

useReducer, reducer函数第二个参数是个数组(A extends AnyActionArg),表示个dispatch接受多个参数，useReducer<S,A>((prevState, actions:[A]))

useRef<T>,参数可以是T，T|null，T|undefined,当时undefiend不可以给null，主要是看元素上的ref如何？元素上的ref接收Ref<T>,RefCallback<T> | RefObject<T | null> | null,就是返回泛型或者null。所以是元素时默认值需要是null，或者在ref中写函数，使用undefined

##### 问题： 常见事件ts

事件常见的属性

currentTarget: 注册事件函数的元素

target: 触发事件的的元素，有可能target是currentTarge的子元素

##### 问题： React 开发者工具

使用 React 开发者工具检查 React components，编辑 props 和 state，并识别性能问题。

##### 问题： React Compiler 介绍

React Compiler 是一个处于 Beta 阶段的新的编译器。 它是一个仅在构建时使用的工具，可以自动优化你的 React 应用程序。它可以与纯 JavaScript 一起使用，并且了解 React 规则，因此你无需重写任何代码即可使用它。

##### 问题： immer 进行state更新

use-immer给出连个方法，userImmer和useImmerReduce，如果状态是嵌套的对象，使用immer修改起来很方便

useImmer返回的一个只读的状态值，和一个设置函数，一般会使用时，传递一个更新函数，函数接受原来的state，可以和immer的produce方法一样直接修改该对象，会返回新的基于修改后的值返回的新的不可变对象

useImmerReduce在useReduce基础上，将第一个参数，reducer，方法的使用produce包装，即reuder接受的状态是收到produce监控的值


##### 问题： Object.freeze 介绍

冻结整个对象的属性，每个属性的writable和configuable置为false，对象的preventExtension置为false。它是浅冻结


##### 问题： immer freeze和produce的原理，简单说说

用 Proxy 把“可变式写法”偷偷转成“不可变式结果”，并在完成后递归 Object.freeze 锁定对象——既让开发者写得舒服，又保证状态真不可变。

freeze通过Object.freeze方法，深度freeze，避免循环引用,判断是否为引用类型**obj!==null && typeof obj==='objject'**,遍历对象 const key of Object.keys(obj)

#### 问题：自己开发的produce的思路

produce有点类似于valtio通过递归proxy来代理整个对象。实现思路是每次访问对象实际是访问一个代理对象。一开始对根对象代理，Proxy(root,handlers),在handler中的get方法，如果访问的值是一个引用类型，继续对这个引用类型进行代理，Proxy(root[p],handlers),这个递归包裹在一个getProxy函数中，还有个参数changedInfo({changeData,parentProp}[])记录了父元素的建克隆和当前对象在父元素的键值 parentProp.在set方法中判断如果当前set的值不相等，那么进行回溯,清空changeInfo数组，进行回溯赋值。

#### 问题：自己开发的produce的问题

对当前对象克隆时，使用了对象扩展运算法，newObj={...obj}，这种方法不能够对数组生效。比较用了lodash的isEqual这是深度比较，是没有用的。采取了在get节点复制，而不是写入复制。没有写delete方法。在写入时每次都回溯来改变值，而不是在完成后进行一次回溯，没有冻结数据，返回不可变数据。

#### symbo作为属性和普通的字符串有什么不同

symbo是唯一的不会与用户定义的键值相冲突;大多数日常操作"for in","Object.keys","JSON.stringify"等不会枚举Symbol键，因此对调用着来说不可见

#### 问题：实际produce方法的原理

实际的immer中的实现，是通过在创建代理时，创建一个state对象，该对象有base（初始对象），copy（复制对象），modified，parent，记录对当前对象的修改，然后将当前对象向下传入下个递归。然后使用了symbol作为键值，DRAFT_STATE


Proxy的逻辑,每当get时，判断当前键值是否是DRAFT_STATE,如果是返回state（说明是内部访问）。如果不是说明访问原来对象的属性，判断当前对象是否改变没改变取原来的对象，改变了取copy；获取值，如果值是对象或者数组，继续递归代理。当set时，判断当前对象是否已经修改过，没修改过设置copy为浅克隆base。并且回溯parent一直浅克隆base为copy并且将parent的modified置为true。在进行set操作。deleteProperty代理和set是样的。

finalize函数是解决的写复制回溯需要修改多次parent。finalize参数是proxy。通过proxy获取state。判断是否修改没有修改就返回base，如果修改了，将result先置为copy。遍历改对象，若果值满足draft（说明获取过），返回递归的finalize。



## 保持组件纯粹

通过将组件按纯函数严格编写，以避免一些随着代码库的增长而出现的、令人困扰的 bug 以及不可预测的行为。但为了获得这些好处，你需要遵循一些规则。

## 保持组件纯粹的问题

问题： 纯函数是什么，在React中的具体表现

问题： 副作用是什么，在React中的具体表现

问题： React为何侧重于纯函数

问题： 哪些地方可能引发副作用

## 保持组件纯粹的详情

##### 问题： 纯函数是什么，在React中的具体表现

纯函数的特征：1)只负责自己的任务。不会更改函数调用前就已存在的对象或变量,2)输入相同，则输出相同.不符合纯函数的是函数有副作用。

React 便围绕着这个概念进行设计。**React 假设你编写的所有组件都是纯函数。**也就是说，对于相同的输入，你所编写的 React 组件必须总是返回相同的 JSX。

改变了预先存在的变量的值，称为突变，mutation。 纯函数不会改变函数作用域外的变量，或在函数调用前创建的对象--这会使函数变得不纯粹。

##### 问题： 副作用是什么，在React中的具体表现

和纯函数的特征想法的现象，副作用描述了函数会改变函数作用域外的变量或者函数调用前创建的对象--即这会使函数变得不纯粹。对React来说React渲染过程必须是纯粹的，相同的输入返回相同的jsx，也不改变在渲染前已经存在的对象或者变量，这会使它变得不纯粹。一般来说你不应期望你的组件会按照某个顺序来渲染。副作用的重点是在对外部的对象的影响，函数内部的改变是局部突变，内部突变是没有问题的。对于react来说渲染过程中的局部修改也是没有问题的。


##### 问题： React为何侧重于纯函数

1. 可预测性 相同的输入返回相同的结果，可以满足在不同环境上，例如在服务器上。

2. 可以安全的缓存。由于有相同的输入输出，react可以安全的将相同的输入结果缓存，跳过渲染。相同的输入可以用来作为判断，完成记忆化，跳过渲染和渲染移到worker等高级优化

3. 并发模式准备 react渲染过程中可能在后台暂停、回复和取消一次渲染。 

构建的每个 React 新特性都利用到了纯函数。从数据获取到动画再到性能，保持组件的纯粹可以充分释放 React 范式的能力。

##### 问题： 哪些地方可能引发副作用

更新屏幕、启动动画、更改数据，它们是额外发生的事情，和渲染过程无关。
在 React 中，副作用通常属于 事件处理程序。事件处理程序是 React 在你执行某些操作（如单击按钮）时运行的函数。即使事件处理程序是在你的组件 内部 定义的，它们也不会在渲染期间运行！ 因此事件处理程序无需是纯函数。
如果你用尽一切办法，仍无法为副作用找到合适的事件处理程序，你还可以调用组件中的 useEffect 方法将其附加到返回的 JSX 中。这会告诉 React 在渲染结束后执行它。然而，这种方法应该是你最后的手段。
如果可能，请尝试仅通过渲染过程来表达你的逻辑。你会惊讶于这能带给你多少好处！


## 状态管理

### 状态管理的问题

问题： useState机制

问题： react的state更新为什么不立即执行

问题： react批处理

问题： state更新函数

问题： 将state视为只读的

问题： 声明式UI和命令式UI的比较

问题： 如何选择state结构

问题： react是如何控制state的保留和重置

问题： 迁移状态到reducer中

问题： react批处理为什么称之为reducer

问题： 什么是关注分离点，react的运用

问题： 对比 useState 和 useReducer

问题： 重写useReducer批处理

问题： 在使用context之前先考虑问题

问题：  context使用场景

问题： 使用 Reducer 和 Context 拓展你的应用

### 状态管理的详情

##### 问题： useState机制

const [index, setIndex] = useState(0);

1. 组件进行第一次渲染。 因为你将 0 作为 index 的初始值传递给 useState，它将返回 [0, setIndex]。 React 记住 0 是最新的 state 值。

2. 你更新了 state。当用户点击按钮时，它会调用 setIndex(index + 1)。 index 是 0，所以它是 setIndex(1)。这告诉 React 现在记住 index 是 1 并触发下一次渲染。

3. 组件进行第二次渲染。React 仍然看到 useState(0)，但是因为 React 记住 了你将 index 设置为了 1，它将返回 [1, setIndex]。

4. 以此类推！

##### 问题： react的state更新为什么不立即执行


- 批量更新：React 通过批量更新来减少渲染的次数。当多个 setState 调用在同一个事件处理程序中时，React 会合并这些更新，只触发一次重新渲染。这有助于提升应用的性能，尤其是在处理复杂的 UI 更新时。

- 事件处理的同步性

一个 state 变量的值永远不会在一次渲染的内部发生变化 会使你的事件处理函数更不容易出现计时错误 React 会使 state 的值始终“固定”在一次渲染的各个事件处理函数内部。你无需担心代码运行时 state 是否发生了变化。

- 生命周期优化：为了避免不必要的渲染，React 会尽量减少对 state 更新的影响，确保只在真正需要的时候才重新渲染组件。例如，组件可能会在状态更新后进行一次“合并”操作，这样它可以更高效地更新和渲染。

- 与 DOM 操作的协调：React 在状态更新时会对虚拟 DOM 进行操作，计算出差异，然后再将差异更新到实际的 DOM。这样做可以避免不必要的直接 DOM 操作，提升性能。

##### 问题： react批处理

React 会等到事件处理函数中的 所有 代码都运行完毕再处理你的 state 更新。 会使你的 React 应用运行得更快。它还会帮你避免处理只更新了一部分 state 变量的令人困惑的“半成品”渲染。 React 不会跨 多个 需要刻意触发的事件（如点击）进行批处理

##### 问题： state更新函数

更新函数。当你将它传递给一个 state 设置函数时： 1. React 会将此函数加入队列，以便在事件处理函数中的所有其他代码运行后进行处理。 2. 在下一次渲染期间，React 会遍历队列并给你更新之后的最终 state。


##### 问题： 将state视为只读的

把所有存放在 state 中的 JavaScript 对象都视为只读的 虽然在一些情况下，直接修改 state 可能是有效的，但我们并不推荐这么做。你应该把在渲染过程中可以访问到的 state 视为只读的。 对于只读的需要返回新的值，原始类型和引用类型，展开语法，更新嵌套对象，Immer


##### 问题： 声明式UI和命令式UI的比较

对于相应用户的操作而变化UI，举例来说表单提交过程，提交按钮和表单ui的变化 在 命令式编程 中，以上的过程直接告诉你如何去实现交互。你必须去根据要发生的事情写一些明确的命令去操作 UI。就像你坐车，告诉司机即js怎么走，一步一步的告诉它。这种告诉计算机如何去更新ui的方式称为命令式编程。 对于独立系统，命令式也不错，但是更加复杂的系统时，造成管理的困难指数级增加。 在React中你不必直接去操作UI-显示、隐藏、启用。想法，你只需要声明你想要显示的内容。react就帮你完成。

##### 问题： 如何选择state结构

选择使用多少个state变量以及它们都是怎样的数据结构

1. 合并关联的state，如果你总是更新两个或更多的state变量，请考虑将他们合并为一个单独的变量

2. 避免互相矛盾的state。

3. 避免冗余的state

4. 避免重复的state

5. 避免深度嵌套的state

##### 问题： react是如何控制state的保留和重置

React 会为 UI 中的组件结构构建 渲染树。

当向一个组件添加状态时，那么可能会认为状态“存在”在组件内。但实际上，状态是由 React 保存的。React 通过组件在渲染树中的位置将它保存的每个状态与正确的组件关联起来。

这是两个独立的 counter，因为它们在树中被渲染在了各自的位置。

相同位置的相同组件会使得 state 被保留下来 

相同位置的不同组件会使 state 重置

在相同位置重置 state，1.渲染不同位置 2. 使用key

##### 问题： 迁移状态到reducer中

对于拥有许多状态更新逻辑的组件来说，过于分散的事件处理程序可能会令人不知所措。对于这种情况，你可以将组件的所有状态更新逻辑整合到一个外部函数中，这个函数叫作 reducer。使用reducer整合状态逻辑,随着组件复杂度的增加，你将很难一眼看清所有的组件状态更新逻辑。例如一个任务列表，三个不同的事件来实现任务的添加、删除和修改。

通过三个步骤将useState迁移到useReducer

将设置状态的逻辑修改为dipatch的一个action

编写一个reducer函数

在你的组件使用reducer

reducer函数接受两个参数，当前state和action对象，并且返回的是更新后的state

```typescript
function yourReducer(state, action) {
  // 给 React 返回更新后的状态
}
```

通常根据action中的type，结合switch语句完成


```typescript
function taskReducer(state: Item[], action: ActionType) {
  const { type } = action;
  switch (type) {
    case "add": {
      return [
        ...state,
        {
          id: action.id,
          done: action.done,
          text: action.text,
        },
      ];
    }
    case "change": {
      return state.map((item) => {
        if (item.id === action.task.id) {
          return action.task;
        } else {
          return item;
        }
      });
    }
    default: {
      return state.filter((item) => item.id !== action.taskId);
    }
  }
}
```

reducer完成后，甚至可以将reducer函数迁移到另外的文件， 像这样关注分离点，我们更容易理解组件的逻辑。现在事件处理函数只通过派发action来指定发生了什么，而reducer通过相应action来决定如何更新。 



##### 问题： react批处理为什么称之为reducer

尽管reducer可以减少代码，但是它是以数组上的reduce命名的 reduce允许你将数组中的多个值累加到一个 reducer函数中，接受当前的状态和一个参数，返回下一个状态。每次调用dispatch就是一次状态的变化，多次变化就类似于讲action执行了多次，每次的状态累积变成最新的状态，也就类似于reduce方法。

##### 问题： 什么是关注分离点，react的运用

关注分离（Separation of Concerns）是一种软件设计原则，核心思想是将程序中不同的功能或“关注点”（concerns）分割到相对独立的部分中进行处理。这样有助于提高代码的可读性、可维护性和可复用性。一旦各部分的功能和职责相对明确，就能最大程度地减少耦合度，从而更容易地对系统进行测试、调试、扩展或重构



##### 问题： 对比 useState 和 useReducer

代码体积 简单的状态useState需要少量代码，但当逻辑变复杂时，特别是很多逻辑以类似的方式修改状态，useReducer可以减少代码

读性。简单的状态useState还行，逻辑变复杂时，useReducer通过关注分离，提高理解和可读性

可调试性 reducer可以通过打印action来发现问题，其实state也可以只是在事件中观察

可测试性 一般来说在真实环境中测试组件，对于复杂的逻辑根据初始state和action来预测也很重要

个人偏好

如果你在修改某些组件状态时经常出现问题或者想给组件添加更多逻辑时，我们建议你还是使用 reducer。当然，你也不必整个项目都用 reducer，这是可以自由搭配的。你甚至可以在一个组件中同时使用 useState 和 useReducer。


##### 问题： 重写useReducer批处理




##### 问题： 在使用context之前先考虑问题

1. props传递的方式，阅读代码更加明晰，哪些组件用了哪些数据

2. 抽象组件并将jsx作为children传递给他们，如果一些中间组件只是来作为样式和与传递的数据无关，则在父组件中定义原来他们的children，传递给中间组件

##### 问题：  context使用场景

主题

当前账户

路由

状态管理 随着应用的增长，最终在靠近顶部的位置可能有很多的state。许多遥远的下层组件可能想要修改他们。通常将reducer和context搭配使用来管理复杂状态并将其传递给深层组件来避免麻烦。

##### 问题： 使用 Reducer 和 Context 拓展你的应用

你可以将 reducer 与 context 相结合，让任何组件读取和更新它的状态。

为子组件提供 state 和 dispatch 函数：

  1. 创建两个 context (一个用于 state,一个用于 dispatch 函数)。

  2. 让组件的 context 使用 reducer。

  3. 使用组件中需要读取的 context。

你可以通过将所有传递信息的代码移动到单个文件中来进一步整理组件。

  你可以导出一个像 TasksProvider 可以提供 context 的组件。

  你也可以导出像 useTasks 和 useTasksDispatch 这样的自定义 Hook。

你可以在你的应用程序中大量使用 context 和 reducer 的组合。


## 脱围机制

有些组件需要控制和同步React之外的系统。BOM，DOM，请求

### 脱围机制的问题

问题： ref最佳实践

问题： ref回调

问题： React何时添加refs

问题： 用 flushSync 同步更新 state 

问题： 什么是effect，它与事件有何不同

问题： 何时不需要effect

问题： 如何编写 Effect 

问题： 你可能不需要effect

问题： 如何移除不必要的effect

问题： 如何判断计算是昂贵的

问题： 常见的实例

问题： Effect 的生命周期与组件的生命周期有何不同

问题： 如何独立地考虑每个 Effect

问题： 什么时候以及为什么 Effect 需要重新同步

问题： 如何确定 Effect 的依赖项

问题： 值是响应式的含义是什么

问题： React 如何使用检查工具验证依赖关系是否正确

问题： 如何区分该使用effect还是事件


### 脱围机制的详情

##### 问题： 什么时候使用ref，ref和state的异同

希望组件记住信息，但是不想触发渲染 ref就像普通的js对象 ref，不会触发渲染，在渲染时是读取不到ref.current需要初始为null，需要再某个时机后获取，挂载，effect之后等。是个可变数据，可读写 例如：timeout ID, DOM元素，其他三方实例

##### 问题： ref最佳实践
将ref视为脱围机制

不要在渲染过程中获取ref.curret（唯一的例外是像 if (!ref.current) ref.current = new Thing() 这样的代码，它只在第一次渲染期间设置一次 ref。）

避免更改由React管理的DOM节点

##### 问题： ref回调

将函数传递给ref属性，这成为ref回调。当需要设置ref时，React将dom节点来调用你的ref回到，并在需要清除它时传入null 参数是node，dom节点。可以返回清理函数，在节点分离时，调用返回的清理函数。

##### 问题： React何时添加refs

在 React 中，每次更新都分为 两个阶段： 在 渲染 阶段， React 调用你的组件来确定屏幕上应该显示什么。 在 提交 阶段， React 把变更应用于 DOM。 通常，你 不希望 在渲染期间访问 refs。这也适用于保存 DOM 节点的 refs。在第一次渲染期间，DOM 节点尚未创建，因此 ref.current 将为 null。在渲染更新的过程中，DOM 节点还没有更新。所以读取它们还为时过早。 React 在提交阶段设置 ref.current。在更新 DOM 之前，React 将受影响的 ref.current 值设置为 null。更新 DOM 后，React 立即将它们设置到相应的 DOM 节点。 通常，你将从事件处理器访问 refs。 如果你想使用 ref 执行某些操作，但没有特定的事件可以执行此操作，你可能需要一个 effect。我们将在下一页讨论 effect。



##### 问题： 用 flushSync 同步更新 state 


一个列表，当添加一条时自动滚动到最后一项。问题是获取的最后一项的dom元素是上次渲染那的，这次需要渲染的state还没有完成渲染。

setTodos([ ...todos, newTodo]);

listRef.current.lastChild.scrollIntoView();

要解决此问题，你可以强制 React 同步更新（“刷新”）DOM。 为此，从 react-dom 导入 flushSync 并将 state 更新包裹 到 flushSync 调用中：

flushSync(() => {

  setTodos([ ...todos, newTodo]);

});

listRef.current.lastChild.scrollIntoView();

这将指示 React 当封装在 flushSync 中的代码执行后，立即同步更新 DOM。因此，当你尝试滚动到最后一个待办事项时，它已经在 DOM 中了：

##### 问题： 什么是effect，它与事件有何不同

在接触 Effect 之前，你需要熟悉 React 组件中的两种逻辑类型：

渲染代码（在 描述 UI 中有介绍）位于组件的顶层。你在这里处理 props 和 state，对它们进行转换，并返回希望在页面上显示的 JSX。渲染代码必须是纯粹的——就像数学公式一样，它只应该“计算”结果，而不做其他任何事情。

事件处理程序（在 添加交互性 中有介绍）是组件内部的嵌套函数，它们不光进行计算, 还会执行一些操作。事件处理程序可能会更新输入字段、提交 HTTP POST 请求来购买产品，或者将用户导航到另一个页面。事件处理程序包含由特定用户操作（例如按钮点击或输入）引起的“副作用”（它们改变了程序的状态）。

Effect 允许你指定由渲染自身，而不是特定事件引起的副作用。在聊天中发送消息是一个“事件”，因为它直接由用户点击特定按钮引起。然而，建立服务器连接是一个 Effect，因为无论哪种交互致使组件出现，它都应该发生。Effect 在 提交 结束后、页面更新后运行。此时是将 React 组件与外部系统（如网络或第三方库）同步的最佳时机。

##### 问题： 何时不需要effect

不要急着在你的组件中使用 Effect。记住，Effect 通常用于暂时“跳出” React 并与一些 外部 系统进行同步。这包括浏览器 API、第三方小部件，以及网络等等。如果你的 Effect 只是根据其他状态来调整某些状态，那么 你可能并不需要一个 Effect。


##### 问题： 如何编写 Effect 

要编写一个 Effect, 请遵循以下三个步骤： 声明 Effect。通常 Effect 会在每次 提交 后运行。 指定 Effect 依赖。大多数 Effect 应该按需运行，而不是在每次渲染后都运行。例如，淡入动画应该只在组件出现时触发。连接和断开服务器的操作只应在组件出现和消失时，或者切换聊天室时执行。你将通过指定 依赖项 来学习如何控制这一点。 必要时添加清理操作。一些 Effect 需要指定如何停止、撤销，或者清除它们所执行的操作。例如，“连接”需要“断开”，“订阅”需要“退订”，而“获取数据”需要“取消”或者“忽略”。你将学习如何通过返回一个 清理函数 来实现这些。 让我们详细看看每一步。 在 Effect 中进行数据请求的替代方案 在 Effect 中直接编写 fetch 请求 是一种常见的数据获取方式，特别是在完全客户端渲染的应用中。然而，这种方法非常手动化，并且有明显的弊端： Effect 不会在服务端运行。这意味着最初由服务器渲染的 HTML 只会包含加载状态，而没有实际数据。客户端必须先下载所有的 JavaScript 并渲染应用，才会发现它需要加载数据——这并不高效。 直接在 Effect 中进行数据请求，容易产生“网络瀑布（network waterfall）”。首先父组件渲染时请求一些数据，随后渲染子组件，接着子组件开始请求它们的数据。如果网络速度不快，这种方式会比并行获取所有数据慢得多。 直接在 Effect 中进行数据请求往往无法预加载或缓存数据。例如，如果组件卸载后重新挂载，它必须重新获取数据。 不够简洁。编写 fecth 请求时为了避免 竞态条件（race condition） 等问题，会需要很多样板代码。 这些弊端并不仅限于 React。任何库在组件挂载时进行数据获取都会遇到这些问题。与路由处理一样，要做好数据获取并非易事，因此我们推荐以下方法： 如果你正在使用 框架 ，请使用其内置的数据获取机制。现代 React 框架集成了高效的数据获取机制，不会出现上述问题。 否则，请考虑使用或构建客户端缓存。流行的开源解决方案包括 React Query、useSWR 和 React Router v6.4+。你也可以自己构建解决方案：在底层使用 Effect，但添加对请求的去重、缓存响应以及避免网络瀑布（通过预加载数据或将数据请求提升到路由层次）的逻辑。 如果这些方法都不适合你，你可以继续直接在 Effect 中获取数据。 



##### 问题： 你可能不需要effect

Effect 是 React 范式中的一种脱围机制。它们让你可以 “逃出” React 并使组件和一些外部系统同步，比如非 React 组件、网络和浏览器 DOM。如果没有涉及到外部系统（例如，你想根据 props 或 state 的变化来更新一个组件的 state），你就不应该使用 Effect。移除不必要的 Effect 可以让你的代码更容易理解，运行得更快，并且更少出错。

##### 问题： 如何移除不必要的effect


你不必使用 Effect 来转换渲染所需的数据 。应在你的组件顶层转换数据。这些代码会在你的 props 或 state 变化时自动重新执行。

你不必使用 Effect 来处理用户事件

如何在没有 Effect 的情况下缓存昂贵的计算

如何在没有 Effect 的情况下重置和调整组件的 state

如何在事件处理函数之间共享逻辑

应该将哪些逻辑移动到事件处理函数中

如何将发生的变动通知到父组件


##### 问题： 如何判断计算是昂贵的

计算时间

##### 问题： 常见的实例


根据props或state来更新state。不需要state，从props和state计算得来

props变化时重置所有的state 通过确定key，React将两个key不一样的组件视为两个不应共享任何状态的不同组件

当props变化时调整部分state 

  存储前序渲染的信息  const [prevItems, setPrevItems] = useState(items); if (items !== prevItems) {setPrevItems(items); setSelection(null);} useState(items);

  无论你怎么做，根据 props 或其他 state 来调整 state 都会使数据流更难理解和调试。总是检查是否可以通过添加 key 来重置所有 state，或者 在渲染期间计算所需内容。

在事件处理函数中共享逻辑。当你不确定某些代码应该放在 Effect 中还是事件处理函数中时，先自问 为什么 要执行这些代码。Effect 只用来执行那些显示给用户时组件 需要执行 的代码。

发送post请求 特别是针对那种依赖的实际上之请求一次，但是要保证某个值为真，要区分对待

链式计算

初始化应用 loadUserData,loadLocalStorageData

通知父组件有关state变化 事件

将数据传递给父组件 改为父组件获取，传递给子组件

订阅外部store  useSyncExternalStore

获取数据  然而，上面的代码有一个问题。假设你快速地输入 “hello”。那么 query 会从 “h” 变成 “he”，“hel”，“hell” 最后是 “hello”。这会触发一连串不同的数据获取请求，但无法保证对应的返回顺序。例如，“hell” 的响应可能在 “hello” 的响应 之后 返回。由于它的 setResults() 是在最后被调用的，你将会显示错误的搜索结果。这种情况被称为 “竞态条件”：两个不同的请求 “相互竞争”，并以与你预期不符的顺序返回。

为了修复这个问题，你需要添加一个 清理函数 来忽略较早的返回结果：
处理竞态条件并不是实现数据获取的唯一难点。你可能还需要考虑缓存响应结果（使用户点击后退按钮时可以立即看到先前的屏幕内容），如何在服务端获取数据（使服务端初始渲染的 HTML 中包含获取到的内容而不是加载动画），以及如何避免网络瀑布（使子组件不必等待每个父组件的数据获取完毕后才开始获取数据）。

这些问题适用于任何 UI 库，而不仅仅是 React。解决这些问题并不容易，这也是现代 框架 提供了比在 Effect 中获取数据更有效的内置数据获取机制的原因。
你可能还想添加一些错误处理逻辑以及跟踪内容是否处于加载中。你可以自己编写这样的 Hook，也可以使用 React 生态中已经存在的许多解决方案。虽然仅仅使用自定义 Hook 不如使用框架内置的数据获取机制高效，但将数据获取逻辑移动到自定义 Hook 中将使后续采用高效的数据获取策略更加容易。

一般来说，当你不得不编写 Effect 时，请留意是否可以将某段功能提取到专门的内置 API 或一个更具声明性的自定义 Hook 中，比如上面的 useData。你会发现组件中的原始 useEffect 调用越少，维护应用将变得更加容易。


##### 问题： Effect 的生命周期与组件的生命周期有何不同

每个 React 组件都经历相同的生命周期： 当组件被添加到屏幕上时，它会进行组件的 挂载。 当组件接收到新的 props 或 state 时，通常是作为对交互的响应，它会进行组件的 更新。 当组件从屏幕上移除时，它会进行组件的 卸载。 这是一种很好的思考组件的方式，但并不适用于 Effect。相反，尝试从组件生命周期中跳脱出来，独立思考 Effect。Effect 描述了如何将外部系统与当前的 props 和 state 同步。随着代码的变化，同步的频率可能会增加或减少。 


##### 问题： 如何独立地考虑每个 Effect


相反，始终专注于单个启动/停止周期。无论组件是挂载、更新还是卸载，都不应该有影响。只需要描述如何开始同步和如何停止。如果做得好，Effect 将能够在需要时始终具备启动和停止的弹性。

##### 问题： 什么时候以及为什么 Effect 需要重新同步

React 通过在开发环境中立即强制 Effect 重新进行同步来验证其是否能够重新同步。 每次在组件重新渲染后，React 都会查看传递的依赖项数组。如果数组中的任何值与上一次渲染时在相同位置传递的值不同，React 将重新同步 Effect。

##### 问题： 如何确定 Effect 的依赖项

每个 Effect 表示一个独立的同步过程 删除一个Effect不会影响另一个Effect的逻辑。这表明它们同步不同的内容。可以将它们分开 将变化的值作为依赖项，不变的无需作为依赖项

##### 问题： 值是响应式的含义是什么

通过将 serverUrl 包含在依赖项中，确保 Effect 在其发生变化后重新同步。 在组件主体中声明的所有变量都是响应式的 组件内部的所有值（包括 props、state 和组件体内的变量）都是响应式的。任何响应式值都可以在重新渲染时发生变化，所以需要将响应式值包括在 Effect 的依赖项中。

##### 问题： React 如何使用检查工具验证依赖关系是否正确

如果检查工具 配置了 React，它将检查 Effect 代码中使用的每个响应式值是否已声明为其依赖项。例如，以下示例是一个 lint 错误，因为 roomId 和 serverUrl 都是响应式的： 与代码检查工具产生分歧时，该如何处理


##### 问题： 如何区分该使用effect还是事件

思考一个聊天室组件：  组件应该自动连接聊天室 当你点击send时，组件应该在当前聊天界面发送一条信息


事件处理函数只在响应特定的交互操作时运行，send应该是事件处理函数

每当需要同步，effect就会运行

另一个参考的角度，是否有响应值的参与，响应值是由state或props来决定的值

事件处理函数的内部逻辑是非响应式的

effect内部的逻辑是响应式的。
