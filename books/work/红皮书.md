# 红皮书

## 第6章 集合引用类型

### 第6章 集合引用类型的问题

### 第6章 集合引用类型的问题详情

##### 问题： Object类型的作用和创建方式

很适合存储和额在应用程序间交换数据，第一种是new Object(),第二种是对象字面量的方式，常用对象字面量的方式，代码量少，方便存储，存取值的方式，通过点语法，或者中括号语法

##### 问题： Array类型的作用和创建方式

js中数组可以存储任意类型的值，数组是动态大小的，会随着数据添加而自动增长

Array构造函数，如果传入值就是表示创建数量，也可以传入要保存的元素，如果只传入一个参数就会有分歧，如果是数字就是长度，其他类型是元素。可以不使用new操作符，第二种方式是数组字面量创建;还有两种创建方式，from和of，from用于将类数组结构转换为数组实例,of用于将一组参数转换为数组实例。from(‘matt’);  [‘m’, ’a’, ’t’, ’t’]


##### 问题： from转换的类型

1）字符串会被拆分为单字符数组

2）可以使用from()将集合（Map）和映射（Set）转换为一个新数组

3）Array.from()对现有数组执行浅复制

4） 可以使用任何可迭代对象，包括yield函数，arguments,类数组对象

Array.from()还接收第二个可选的映射函数参数,还可以接收第三个可选参数，用于指定映射函数中this的值。但这个重写的this值在箭头函数中不适用。

##### 问题： 数组空位问题

通过[1,,,4]来创建数组空位，es6新增的方式会将其当做值为undefined元素，早起es中的方法表现不一致，会忽略空位。

所以不要使用空位，即使要用也要使用显示的undefined


##### 问题：数组索引问题

通过中括号来获取，leng会自动增加。length不是只读的，通过设置length可以添加和删除元素

##### 问题：检测数组

如果只有一个全局那么instanceof array就可以解决，如果多个全局上下文，上下文1创建的数组不是上下文2的Array构造的。

es6 添加了Array.isArray来判断数组

##### 数组的一些方法

迭代器方法-- keys values entries

复制和填充方法-- fill 参数：填充内容，开始索引，结束索引。开始和结束是可选，如果是一个负数从结尾开始算，会自动忽略不满足的索引，超出范围的，结束小于开始的，满足一个填一个 copyWith 参数：开始插入索引，开始复制的索引，结束的索引。开始和结束可选。开始默认0;在大数组场景（图像、音频、科学计算）尤其明显。

转换方法-- toString,valueOf,toLocalString,其中local会调用每个元素的local再拼接

栈，队列和排序方法-- push返回长度，pop返回删除的元素，LIFO shift返回数组长度，unshift返回删除的元素，LILO

操作方法-- concat,slice,splice

搜索和位置方法-- 严格相等的方式，indexOf,lastIndexOf,includes，接受连个参数，搜索的值和开始索引 断言函数，find,findIndex

迭代方法-- every,filter,forEach,map,some

归并方法-- reduce,reduceRight

##### 问题： 定型数组历史

随着浏览器的发展，人们在复杂的3d运行程序方面越来越期待。webGl（Web Graphics Library）中，js数组与原生数组之间不匹配，出现了性能问题。图形驱动程序api通常不需要以js默认的双精度浮点。创建了c语言风格的浮点值数组

##### 问题： ArrayBuffer和视图的简单概念

ArrayBuffer的预分配内存, ArrayBuffer是所有定型数组及视图引用的基本单位,供视图使用。ArrayBuffer是一个普通的js构造函数，可用于在内存中分配特定数量的字节空间。一经创建不能调整大小。

视图1. DataView,专为文件IO和网络IO设计。

视图2，定型数组 设计定型数组的目的就是提高与WebGL等原生库交换二进制数据的效率。由于定型数组的二进制表示对操作系统而言是一种容易使用的格式，JavaScript引擎可以重度优化算术运算、按位运算和其他对定型数组的常见操作，因此使用它们速度极快。

##### 问题： Map基本方法。顺序和迭代，如何选择

创建 如果想在创建的同时初始化实例，可以给Map构造函数传入一个可迭代对象，需要包含键/值对数组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中：

```JavaScript

new Map();

new Map([[‘k1’,’v1’]]);

new Map({
  [Symbol.iterator]:function *() {
      yield [‘k1’,’v1’];
      yield [‘’k2,’v2’]
    }
  });

```

通过size获取map中的元素个数

基本方法：set,get,has,delete,clear


建值要求： 任意js类型，内部使用SaveValueZero比较


Map会维护键值对的插入顺序，根据插入顺序迭代--entries,forEach,keys,values

对于多数web开发任务来说使用object还是map是个人偏好，不过对于性能和内存开发者来说，有区别：

1．内存占用-- Object和Map的工程级实现在不同浏览器间存在明显差异，但存储单个键/值对所占用的内存数量都会随键的数量线性增加。批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现。不同浏览器的情况不同，但给定固定大小的内存，Map大约可以比Object多存储50%的键/值对。

2．插入性能-- 向Object和Map中插入新键/值对的消耗大致相当，不过插入Map在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。如果代码涉及大量插入操作，那么显然Map的性能更佳。

3．查找速度-- 与插入不同，从大型Object和Map中查找键/值对的性能差异极小，但如果只包含少量键/值对，则Object有时候速度更快。在把Object当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。这对Map来说是不可能的。对这两个类型而言，查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选择Object更好一些。

4．删除性能-- 使用delete删除Object属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，出现了一些伪删除对象属性的操作，包括把属性值设置为undefined或null。但很多时候，这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map的delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择Map。

##### 问题： WeakMap的基本使用

WeakMap的键要求是Object类型，是弱键，不会影响垃圾回收。基本方法和Map一致,无clear

不可迭代的键

使用场景：1）私有变量 2）DOM 节点元素

##### 问题： Set的基本方法

创建，new Set（）,初始值通过传入可迭代对象，返回元素。通过size属性获取元素个数，方法包括add,has,delete,clear,内部使用SameValueZero来比较元素是否相同

Set的迭代，其中values和keys都返回set的迭代器，entries返回[v1,v1]


##### 问题： WeakSet


##### 问题： 顺序与迭代

数组，定型数组，Map，Set都支持顺序迭代，扩展操作符在对可迭代对象执行浅复制时特别有用，只需简单的语法就可以复制整个对象


## 第7章 迭代器与生成器

### 第7章 迭代器与生成器的问题

### 第7章 迭代器与生成器的问题详情

##### 问题： js原有迭代方式的理解

在js中原理的支持迭代的是数组，数组有长度，通过递增的索引来完成迭代。这种迭代存在两个问题：1）每次迭代需要通过数组本身加中括号索引来访问，访问的方式和当前数据结构产生了关联，很多时候迭代器本身不关心当前的数据结构。2）迭代器通过递增的索引来顺序迭代，其他的数据结构不符合递增的索引，有的是隐式的迭代索引

##### 问题： 迭代器模式的理解，实现iterable的要求，支持iterator的原生方法

迭代器模式描述了一个方案，可以把有些结构称为可迭代对象，因为它们实现了正式的Iterable接口，而且可以通过迭代器Iterator消费。迭代器无需了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这种概念上的分离正是Iterable和Iterator的强大之处。

实现Iterable接口（可迭代协议）要求有两种能力，识别可以迭代，创建实现Iterator接口的对象能力；在js中是通过Symbole.interator这个特殊属性来表示，该属性对应的值是迭代器工厂函数，调用这个函数返回新的迭代器。

很多类型实现了内置的Iterable接口，字符串，数组，集合，映射，argumens,nodeList

接口可迭代的原生语言特性，for of, 数组结构， 扩展运算符， Array.from, 创建集合， 创建映射， Promise.all, Promise.race,yield *操作符

##### 问题： 迭代器协议

迭代器是一种一次性使用的对象，使用next方法遍历数据，next方法返回IterarotResult，包含done和value。 当done为true时，value为undefined。迭代器方法保存了原始的数据引用，每个迭代器对象保留了迭代的索引。所以在迭代过程中改变某个值，是可行的。但是改变迭代的次数是不行的。每个迭代器对象互不影响

自定义迭代器: 通过Symbol.interator属性来给某个数据添加iterable。该构造方法返回一个包含next方法的对象。每次生成迭代器对象都保留了便利索引

##### 问题： 提前终止迭代器

可选的return方法用于指定在迭代器提前关闭时执行的逻辑。可能的情况包括： for of 循环中break,continue,return和throw提前退出。解构并未消费所有值。return需要返回IteratorResult，{done: true}



##### 问题： 生成器基础

定义生成器函数，在函数名前加一个*，星号两边的空格没有影响。箭头函数不能当做生成器函数。

调用生成器方法会产生一个生成器对象。生成器对象一开始处于暂停状态（suspend)。 与迭代器相似，生成器对象也实现了Iterator接口，因此具有next方法。函数的返回值会被包装成{done:true,value:返回值}。生成器对象实现了Iterable接口，它们默认的迭代器是自引用的。

可以通过yield中断执行,yield关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到yield关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用next()方法来恢复执行。yield关键字有点像函数的中间返回语句

##### 问题： 生成器的一些应用

1） 生成器用来自定义迭代器

2）使用yield实现输入和输出，上一次让生成器函数暂停的yield关键字会接收到传给next（）方法的第一个值。第一次调用next（）传入的值不会被使用。

3） 产生可迭代对象 yield* [1, 2, 3];

4） 使用yield* 实现递归


## 第8章 对象、类与面向对象编程

### 第8章 对象、类与面向对象编程的问题

### 第8章 对象、类与面向对象编程的问题详情

##### 问题： 对象的数据属性,访问器属性,defineProperty,defineProperties，读取属性的特性,合并操作

数据属性: value— 值,writable— 是否可写入，控制只读,configurable— 是否可删除并重新定义，是否可以修改它的特性，以及是否可以改为访问器属性 ,enumerable— 是否可以通过for-in返回

configurable,enumerable,writable默认为true

修改数据属性需要使用Object.defineProperty()方法，接收3个参数：修改对象，属性，属性描述对象,调用Object.defineProperty时，configurable,enumerable,writable默认为false

访问器属性: configurable,enumerable,get,set,其中get、set是可选的

Object.define-Properties(),可以通过多个描述符一次性定义多个属性,参数： 修改的对象，描述对象

Object.getOwnPropertyDescriptor(), es 2017新增，Object.getOwnPropertyDescriptors

##### 问题： 相等判定？

Object.is,与===很像。结局了NaN和NaN不相等，+0和-0相等得问题

##### 问题： 对象增强语法

1） 简写属性名 {name} 2） 可计算属性名，[key] 3） 简写方法名

### 问题： 对象解构

设置默认值，可以嵌套解构，部分解构，参数上下文匹配 {originKey:curKey} = obj1;

##### 问题：工厂模式和构造函数

工厂模式，显式创建对象，给对象添加属性，返回对象
构造函数 不需要显式创建对象，内部this指向该对象，返回这个对象。构造函数可以给创建对象标识类型。构造函数即是普通函数，存在的问题是对象的属性都要添加一遍

##### 问题：new操作符过程

创建对象，对象的prototype特性被赋值为函数的prototype属性，this指向该对象，执行，如果没有返回非空对象返回还对象，否则返回数据

##### 问题： 原型模式,相关的方法

每个函数都会有一个原型对象prototype，其中会默认添加construtor属性指向该函数。创建的对象的 [[prototype]] 属性指向该原型对象。原型对象上的属性可以实例访问到，这就解决了实例共享相同属性。

原型对象有一种机制可以访问父级构造的原型对象，称为原型链。

isPrototypeOf,getPrototypeOf,setPrototypeOF,hasOwnProperty,getOwnPropertyDescriptor,Object.create

访问对象的属性是，首先在实例属性寻找，没有找到在原型对象上找，没有找到继续在父原型对象上找，直到Object的原型。

in操作符: in操作法有两种使用方式，单独使用和在for-in使用。单独使用时，会根据属性是否存在返回true，k in obj。

属性枚举方法： for-in,Object.keys,Object.getOwnPropertyNames,Object.getOwnPropertSymbols,Object.assigna

方法的原型对象可以直接以对象形式赋值；原型是动态的；原生对象原型；原型对象的引用类型属性，在每个实例都可以被访问那么久都可以被修改！！


##### 问题： 对象的迭代

values,entries,符号属性会被忽略

##### 继承

继承是面向对象编程中讨论最多的话题。很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在ECMAScript中是不可能的，因为函数没有签名。实现继承是ECMAScript唯一支持的继承方式，而这主要是通过原型链实现的。

##### 问题： 原型链理解

原型对象中有一个指针，指向父原型对象。以此类推，形成一个原型链。

原型链中有一个默认的Object原型，其中方法包括 toString,toLocalString,valueOf,hasOwnProperty,isPrototypeOf,可以通过 instanceof 操作符和isPrototypeOf两种方法来确定实例和构造之间的关系。

原型链的问题：引用值

##### 问题： 解决引用类型继承的方法

盗用构造函数,组合继承,原型式继承,寄生式继承



##### 问题： 解决引用类型继承的方法

**盗用构造函数**，对象伪装，经典集成。在子类构造函数中调用父类构造函数。使用apply和call方法一新创建的对象为上下文执行构造函数

```JavaScript
function Supper(){
  this.colors = ['red','blue','green'];
}
function Sub(){
  Supper.call(this);
}
```

盗用构造函数的问题： 必须在构造函数中定义方法，因此函数不能重用。子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。由于存在这些问题，盗用构造函数基本上也不能单独使用。

**组合继承** 伪经典继承综合了原型链和盗用构造函数，将两者的优点集中起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。组合继承弥补了原型链和盗用构造函数的不足，是js中使用最多的继承模式。

```JavaScript
function Supper(){
  this.colors = ['red','blue','green'];
}
Supper.prototype.say = function (){}
function Sub(){
  Supper.call(this);
}

Sub.prototype = new Supper();

```
##### 问题： 原型式继承

即使不自定义类型也可以通过原型实现对象之间的信息共享

```JavaScript
​​​​​​function object(o) {￼​
​​​ function F() {}
 F.prototype = o;￼
 return new F();￼
​​​​}
```

es5 增加的Object.create将原型式集成的概念规范化了，这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，Object.create()与这里的object()方法效果相同

##### 问题： 寄生式继承

类似于寄生构造函数和工厂模式： 创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象

```JavaScript
function cAnother(original) {
	let clone = object(original);
	clone.sayHai = function(){
		console.log(‘hi’);	
	}
	return clone
}
```
##### 问题： 寄生式组合继承的理解

组合继承其实也存在效率问题，最主要的问题是父类构造函数会被调用两次。

寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型

```JavaScript
function inheritPrototype(subType, superType) {￼
  let prototype = object(superType.prototype);// 创建对象
  prototype.constructor = subType;// 增强对象
  subType.prototype = prototype;// 赋值对象​
​​}​​

```

这个inheritPrototype()函数实现了寄生式组合继承的核心逻辑。这个函数接收两个参数：子类构造函数和父类构造函数。在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的prototype对象设置constructor属性，解决由于重写原型导致默认constructor丢失的问题。最后将新创建的对象赋值给子类型的原型。

寄生式组合继承可以算是引用类型继承的最佳模式。

##### 问题： 类的理解

虽然看上去支持正式的面向对象编程，实际上它背后使用的仍然是原型和构造函数的概念。

类定义的两种方式 class Person{}; const Animal = class{}; 类定义不能提升，类受块作用域限制。


把类当做一个特殊函数。

##### 问题： 实例、原型和类成员

在contructor方法中添加实例属性；在类中定义的属性和方法即是在原型对象上，也支持设置访问器属性， set name(){}, get name(){};静态方法

##### 问题： 类继承的理解

基础继承，使用extends关键字，只要满足有[[construct]]属性和原型对象

构造函数、HomeObject和super(),派生类的方法可以通过super关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部

// 不要在调用super()之前引用this，否则会抛出ReferenceError￼ super(); // 相当于super.constructor()￼

注意 ES6给类构造函数和静态方法添加了内部特性[[HomeObject]]，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在JavaScript引擎内部访问。super始终会定义为[[HomeObject]]的原型。


抽象基类, new.target 访问new 调用的方法。例如可以防止某个抽象类被实例化

继承内置类型

类混入

注意 很多JavaScript框架（特别是React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（composition over inheritance）。”这个设计原则被很多人遵循，在代码设计中能提供极大的灵活性。